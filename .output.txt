node_modules/expo/node_modules/@expo/cli/package.json:    "@expo/osascript": "^2.3.8",
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/AppleDeviceManager.js:function _osascript() {
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/AppleDeviceManager.js:    const data = /*#__PURE__*/ _interop_require_wildcard(require("@expo/osascript"));
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/AppleDeviceManager.js:    _osascript = function() {
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/AppleDeviceManager.js:        await _osascript().execAsync(`tell application "Simulator" to activate`);
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/ensureSimulatorAppRunning.js:function _osascript() {
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/ensureSimulatorAppRunning.js:    const data = /*#__PURE__*/ _interop_require_wildcard(require("@expo/osascript"));
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/ensureSimulatorAppRunning.js:    _osascript = function() {
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/ensureSimulatorAppRunning.js:        const zeroMeansNo = (await _osascript().execAsync('tell app "System Events" to count processes whose name is "Simulator"')).trim();
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/AppleDeviceManager.js.map:{"version":3,"sources":["../../../../../src/start/platforms/ios/AppleDeviceManager.ts"],"sourcesContent":["import * as osascript from '@expo/osascript';\nimport assert from 'assert';\nimport chalk from 'chalk';\nimport fs from 'fs';\nimport path from 'path';\n\nimport { assertSystemRequirementsAsync } from './assertSystemRequirements';\nimport { ensureSimulatorAppRunningAsync } from './ensureSimulatorAppRunning';\nimport {\n  getBestBootedSimulatorAsync,\n  getBestUnbootedSimulatorAsync,\n  getSelectableSimulatorsAsync,\n} from './getBestSimulator';\nimport { promptAppleDeviceAsync } from './promptAppleDevice';\nimport * as SimControl from './simctl';\nimport { delayAsync, waitForActionAsync } from '../../../utils/delay';\nimport { CommandError } from '../../../utils/errors';\nimport { parsePlistAsync } from '../../../utils/plist';\nimport { validateUrl } from '../../../utils/url';\nimport { DeviceManager } from '../DeviceManager';\nimport { ExpoGoInstaller } from '../ExpoGoInstaller';\nimport { BaseResolveDeviceProps } from '../PlatformManager';\n\nconst debug = require('debug')('expo:start:platforms:ios:AppleDeviceManager') as typeof console.log;\n\nconst EXPO_GO_BUNDLE_IDENTIFIER = 'host.exp.Exponent';\n\n/**\n * Ensure a simulator is booted and the Simulator app is opened.\n * This is where any timeout related error handling should live.\n */\nexport async function ensureSimulatorOpenAsync(\n  { udid, osType }: Partial<Pick<SimControl.Device, 'udid' | 'osType'>> = {},\n  tryAgain: boolean = true\n): Promise<SimControl.Device> {\n  // Use a default simulator if none was specified\n  if (!udid) {\n    // If a simulator is open, side step the entire booting sequence.\n    const simulatorOpenedByApp = await getBestBootedSimulatorAsync({ osType });\n    if (simulatorOpenedByApp) {\n      return simulatorOpenedByApp;\n    }\n\n    // Otherwise, find the best possible simulator from user defaults and continue\n    const bestUdid = await getBestUnbootedSimulatorAsync({ osType });\n    if (!bestUdid) {\n      throw new CommandError('No simulators found.');\n    }\n    udid = bestUdid;\n  }\n\n  const bootedDevice = await waitForActionAsync({\n    action: () => {\n      // Just for the type check.\n      assert(udid);\n      return SimControl.bootAsync({ udid });\n    },\n  });\n\n  if (!bootedDevice) {\n    // Give it a second chance, this might not be needed but it could potentially lead to a better UX on slower devices.\n    if (tryAgain) {\n      return await ensureSimulatorOpenAsync({ udid, osType }, false);\n    }\n    // TODO: We should eliminate all needs for a timeout error, it's bad UX to get an error about the simulator not starting while the user can clearly see it starting on their slow computer.\n    throw new CommandError(\n      'SIMULATOR_TIMEOUT',\n      `Simulator didn't boot fast enough. Try opening Simulator first, then running your app.`\n    );\n  }\n  return bootedDevice;\n}\nexport class AppleDeviceManager extends DeviceManager<SimControl.Device> {\n  static assertSystemRequirementsAsync = assertSystemRequirementsAsync;\n\n  static async resolveAsync({\n    device,\n    shouldPrompt,\n  }: BaseResolveDeviceProps<\n    Partial<Pick<SimControl.Device, 'udid' | 'osType'>>\n  > = {}): Promise<AppleDeviceManager> {\n    if (shouldPrompt) {\n      const devices = await getSelectableSimulatorsAsync(device);\n      device = await promptAppleDeviceAsync(devices, device?.osType);\n    }\n\n    const booted = await ensureSimulatorOpenAsync(device);\n    return new AppleDeviceManager(booted);\n  }\n\n  get name() {\n    return this.device.name;\n  }\n\n  get identifier(): string {\n    return this.device.udid;\n  }\n\n  async getAppVersionAsync(\n    appId: string,\n    { containerPath }: { containerPath?: string } = {}\n  ): Promise<string | null> {\n    return await SimControl.getInfoPlistValueAsync(this.device, {\n      appId,\n      key: 'CFBundleShortVersionString',\n      containerPath,\n    });\n  }\n\n  async startAsync(): Promise<SimControl.Device> {\n    return ensureSimulatorOpenAsync({ osType: this.device.osType, udid: this.device.udid });\n  }\n\n  async launchApplicationIdAsync(appId: string) {\n    try {\n      const result = await SimControl.openAppIdAsync(this.device, {\n        appId,\n      });\n      if (result.status === 0) {\n        await this.activateWindowAsync();\n      } else {\n        throw new CommandError(result.stderr);\n      }\n    } catch (error: any) {\n      let errorMessage = `Couldn't open iOS app with ID \"${appId}\" on device \"${this.name}\".`;\n      if (error instanceof CommandError && error.code === 'APP_NOT_INSTALLED') {\n        if (appId === EXPO_GO_BUNDLE_IDENTIFIER) {\n          errorMessage = `Couldn't open Expo Go app on device \"${this.name}\". Install it: https://expo.dev/go.`;\n        } else {\n          errorMessage += `\\nThe app might not be installed, try installing it with: ${chalk.bold(\n            `npx expo run:ios -d ${this.device.udid}`\n          )}`;\n        }\n      }\n      if (error.stderr) {\n        errorMessage += chalk.gray(`\\n${error.stderr}`);\n      } else if (error.message) {\n        errorMessage += chalk.gray(`\\n${error.message}`);\n      }\n      throw new CommandError(errorMessage);\n    }\n  }\n\n  async installAppAsync(filePath: string) {\n    await SimControl.installAsync(this.device, {\n      filePath,\n    });\n\n    await this.waitForAppInstalledAsync(await this.getApplicationIdFromBundle(filePath));\n  }\n\n  private async getApplicationIdFromBundle(filePath: string): Promise<string> {\n    debug('getApplicationIdFromBundle:', filePath);\n    const builtInfoPlistPath = path.join(filePath, 'Info.plist');\n    if (fs.existsSync(builtInfoPlistPath)) {\n      const { CFBundleIdentifier } = await parsePlistAsync(builtInfoPlistPath);\n      debug('getApplicationIdFromBundle: using built Info.plist', CFBundleIdentifier);\n      return CFBundleIdentifier;\n    }\n    debug('getApplicationIdFromBundle: no Info.plist found');\n    return EXPO_GO_BUNDLE_IDENTIFIER;\n  }\n\n  private async waitForAppInstalledAsync(applicationId: string): Promise<boolean> {\n    while (true) {\n      if (await this.isAppInstalledAndIfSoReturnContainerPathForIOSAsync(applicationId)) {\n        return true;\n      }\n      await delayAsync(100);\n    }\n  }\n\n  async uninstallAppAsync(appId: string) {\n    await SimControl.uninstallAsync(this.device, {\n      appId,\n    });\n  }\n\n  async isAppInstalledAndIfSoReturnContainerPathForIOSAsync(appId: string) {\n    return (\n      (await SimControl.getContainerPathAsync(this.device, {\n        appId,\n      })) ?? false\n    );\n  }\n\n  async openUrlAsync(url: string, options: { appId?: string } = {}) {\n    // Non-compliant URLs will be treated as application identifiers.\n    if (!validateUrl(url, { requireProtocol: true })) {\n      return await this.launchApplicationIdAsync(url);\n    }\n\n    try {\n      await SimControl.openUrlAsync(this.device, { url, appId: options.appId });\n    } catch (error: any) {\n      // 194 means the device does not conform to a given URL, in this case we'll assume that the desired app is not installed.\n      if (error.status === 194) {\n        // An error was encountered processing the command (domain=NSOSStatusErrorDomain, code=-10814):\n        // The operation couldn’t be completed. (OSStatus error -10814.)\n        //\n        // This can be thrown when no app conforms to the URI scheme that we attempted to open.\n        throw new CommandError(\n          'APP_NOT_INSTALLED',\n          `Device ${this.device.name} (${this.device.udid}) has no app to handle the URI: ${url}`\n        );\n      }\n      throw error;\n    }\n  }\n\n  async activateWindowAsync() {\n    await ensureSimulatorAppRunningAsync(this.device);\n    // TODO: Focus the individual window\n    await osascript.execAsync(`tell application \"Simulator\" to activate`);\n  }\n\n  getExpoGoAppId(): string {\n    return EXPO_GO_BUNDLE_IDENTIFIER;\n  }\n\n  async ensureExpoGoAsync(sdkVersion: string): Promise<boolean> {\n    const installer = new ExpoGoInstaller('ios', EXPO_GO_BUNDLE_IDENTIFIER, sdkVersion);\n    return installer.ensureAsync(this);\n  }\n}\n"],"names":["AppleDeviceManager","ensureSimulatorOpenAsync","debug","require","EXPO_GO_BUNDLE_IDENTIFIER","udid","osType","tryAgain","simulatorOpenedByApp","getBestBootedSimulatorAsync","bestUdid","getBestUnbootedSimulatorAsync","CommandError","bootedDevice","waitForActionAsync","action","assert","SimControl","bootAsync","DeviceManager","assertSystemRequirementsAsync","resolveAsync","device","shouldPrompt","devices","getSelectableSimulatorsAsync","promptAppleDeviceAsync","booted","name","identifier","getAppVersionAsync","appId","containerPath","getInfoPlistValueAsync","key","startAsync","launchApplicationIdAsync","result","openAppIdAsync","status","activateWindowAsync","stderr","error","errorMessage","code","chalk","bold","gray","message","installAppAsync","filePath","installAsync","waitForAppInstalledAsync","getApplicationIdFromBundle","builtInfoPlistPath","path","join","fs","existsSync","CFBundleIdentifier","parsePlistAsync","applicationId","isAppInstalledAndIfSoReturnContainerPathForIOSAsync","delayAsync","uninstallAppAsync","uninstallAsync","getContainerPathAsync","openUrlAsync","url","options","validateUrl","requireProtocol","ensureSimulatorAppRunningAsync","osascript","execAsync","getExpoGoAppId","ensureExpoGoAsync","sdkVersion","installer","ExpoGoInstaller","ensureAsync"],"mappings":"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"}
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/ios/ensureSimulatorAppRunning.js.map:{"version":3,"sources":["../../../../../src/start/platforms/ios/ensureSimulatorAppRunning.ts"],"sourcesContent":["import * as osascript from '@expo/osascript';\nimport spawnAsync from '@expo/spawn-async';\n\nimport { Device } from './simctl';\nimport * as Log from '../../../log';\nimport { waitForActionAsync } from '../../../utils/delay';\nimport { CommandError } from '../../../utils/errors';\n\n/** Open the Simulator.app and return when the system registers it as 'open'. */\nexport async function ensureSimulatorAppRunningAsync(\n  device: Partial<Pick<Device, 'udid'>>,\n  {\n    maxWaitTime,\n  }: {\n    maxWaitTime?: number;\n  } = {}\n): Promise<void> {\n  if (await isSimulatorAppRunningAsync()) {\n    return;\n  }\n\n  Log.log(`\\u203A Opening the iOS simulator, this might take a moment.`);\n\n  // In theory this would ensure the correct simulator is booted as well.\n  // This isn't theory though, this is Xcode.\n  await openSimulatorAppAsync(device);\n\n  if (!(await waitForSimulatorAppToStart({ maxWaitTime }))) {\n    throw new CommandError(\n      'SIMULATOR_TIMEOUT',\n      `Simulator app did not open fast enough. Try opening Simulator first, then running your app.`\n    );\n  }\n}\n\nasync function waitForSimulatorAppToStart({\n  maxWaitTime,\n}: { maxWaitTime?: number } = {}): Promise<boolean> {\n  return waitForActionAsync<boolean>({\n    interval: 50,\n    maxWaitTime,\n    action: isSimulatorAppRunningAsync,\n  });\n}\n\n// I think the app can be open while no simulators are booted.\nasync function isSimulatorAppRunningAsync(): Promise<boolean> {\n  try {\n    const zeroMeansNo = (\n      await osascript.execAsync(\n        'tell app \"System Events\" to count processes whose name is \"Simulator\"'\n      )\n    ).trim();\n    if (zeroMeansNo === '0') {\n      return false;\n    }\n  } catch (error: any) {\n    if (error.message.includes('Application isn’t running')) {\n      return false;\n    }\n    throw error;\n  }\n\n  return true;\n}\n\nasync function openSimulatorAppAsync(device: { udid?: string }) {\n  const args = ['-a', 'Simulator'];\n  if (device.udid) {\n    // This has no effect if the app is already running.\n    args.push('--args', '-CurrentDeviceUDID', device.udid);\n  }\n  await spawnAsync('open', args);\n}\n"],"names":["ensureSimulatorAppRunningAsync","device","maxWaitTime","isSimulatorAppRunningAsync","Log","log","openSimulatorAppAsync","waitForSimulatorAppToStart","CommandError","waitForActionAsync","interval","action","zeroMeansNo","osascript","execAsync","trim","error","message","includes","args","udid","push","spawnAsync"],"mappings":";;;;+BASsBA;;;eAAAA;;;;iEATK;;;;;;;gEACJ;;;;;;6DAGF;uBACc;wBACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGtB,eAAeA,+BACpBC,MAAqC,EACrC,EACEC,WAAW,EAGZ,GAAG,CAAC,CAAC;IAEN,IAAI,MAAMC,8BAA8B;QACtC;IACF;IAEAC,KAAIC,GAAG,CAAC,CAAC,2DAA2D,CAAC;IAErE,uEAAuE;IACvE,2CAA2C;IAC3C,MAAMC,sBAAsBL;IAE5B,IAAI,CAAE,MAAMM,2BAA2B;QAAEL;IAAY,IAAK;QACxD,MAAM,IAAIM,oBAAY,CACpB,qBACA,CAAC,2FAA2F,CAAC;IAEjG;AACF;AAEA,eAAeD,2BAA2B,EACxCL,WAAW,EACc,GAAG,CAAC,CAAC;IAC9B,OAAOO,IAAAA,yBAAkB,EAAU;QACjCC,UAAU;QACVR;QACAS,QAAQR;IACV;AACF;AAEA,8DAA8D;AAC9D,eAAeA;IACb,IAAI;QACF,MAAMS,cAAc,AAClB,CAAA,MAAMC,aAAUC,SAAS,CACvB,wEACF,EACAC,IAAI;QACN,IAAIH,gBAAgB,KAAK;YACvB,OAAO;QACT;IACF,EAAE,OAAOI,OAAY;QACnB,IAAIA,MAAMC,OAAO,CAACC,QAAQ,CAAC,8BAA8B;YACvD,OAAO;QACT;QACA,MAAMF;IACR;IAEA,OAAO;AACT;AAEA,eAAeV,sBAAsBL,MAAyB;IAC5D,MAAMkB,OAAO;QAAC;QAAM;KAAY;IAChC,IAAIlB,OAAOmB,IAAI,EAAE;QACf,oDAAoD;QACpDD,KAAKE,IAAI,CAAC,UAAU,sBAAsBpB,OAAOmB,IAAI;IACvD;IACA,MAAME,IAAAA,qBAAU,EAAC,QAAQH;AAC3B"}
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/android/activateWindow.js:function _osascript() {
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/android/activateWindow.js:    const data = /*#__PURE__*/ _interop_require_wildcard(require("@expo/osascript"));
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/android/activateWindow.js:    _osascript = function() {
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/android/activateWindow.js:        await _osascript().execAsync(`
node_modules/expo/node_modules/@expo/cli/build/src/start/platforms/android/activateWindow.js.map:{"version":3,"sources":["../../../../../src/start/platforms/android/activateWindow.ts"],"sourcesContent":["import * as osascript from '@expo/osascript';\nimport { execFileSync } from 'child_process';\n\nimport { Device } from './adb';\n\nconst debug = require('debug')('expo:start:platforms:android:activateWindow') as typeof console.log;\n\nfunction getUnixPID(port: number | string): string {\n  // Runs like `lsof -i:8081 -P -t -sTCP:LISTEN`\n  const args = [`-i:${port}`, '-P', '-t', '-sTCP:LISTEN'];\n  debug('lsof ' + args.join(' '));\n  return execFileSync('lsof', args, {\n    encoding: 'utf8',\n    stdio: ['pipe', 'pipe', 'ignore'],\n  })\n    .split('\\n')[0]\n    ?.trim?.();\n}\n\n/** Activate the Emulator window on macOS. */\nexport async function activateWindowAsync(device: Pick<Device, 'type' | 'pid'>): Promise<boolean> {\n  debug(`Activating window for device (pid: ${device.pid}, type: ${device.type})`);\n  if (\n    // only mac is supported for now.\n    process.platform !== 'darwin' ||\n    // can only focus emulators\n    device.type !== 'emulator'\n  ) {\n    return false;\n  }\n\n  // Google Emulator ID: `emulator-5554` -> `5554`\n  const androidPid = device.pid!.match(/-(\\d+)/)?.[1];\n  if (!androidPid) {\n    return false;\n  }\n  // Unix PID\n  const pid = getUnixPID(androidPid);\n\n  if (!pid) {\n    return false;\n  }\n  debug(`Activate window for pid:`, pid);\n  try {\n    await osascript.execAsync(`\n    tell application \"System Events\"\n      set frontmost of the first process whose unix id is ${pid} to true\n    end tell`);\n    return true;\n  } catch {\n    // noop -- this feature is very specific and subject to failure.\n    return false;\n  }\n}\n"],"names":["activateWindowAsync","debug","require","getUnixPID","port","execFileSync","args","join","encoding","stdio","split","trim","device","pid","type","process","platform","androidPid","match","osascript","execAsync"],"mappings":";;;;+BAoBsBA;;;eAAAA;;;;iEApBK;;;;;;;yBACE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAI7B,MAAMC,QAAQC,QAAQ,SAAS;AAE/B,SAASC,WAAWC,IAAqB;QAIhCC,2BAAAA;IAHP,8CAA8C;IAC9C,MAAMC,OAAO;QAAC,CAAC,GAAG,EAAEF,MAAM;QAAE;QAAM;QAAM;KAAe;IACvDH,MAAM,UAAUK,KAAKC,IAAI,CAAC;IAC1B,QAAOF,uBAAAA,IAAAA,6BAAY,EAAC,QAAQC,MAAM;QAChCE,UAAU;QACVC,OAAO;YAAC;YAAQ;YAAQ;SAAS;IACnC,GACGC,KAAK,CAAC,KAAK,CAAC,EAAE,sBAJVL,4BAAAA,qBAKHM,IAAI,qBALDN,+BAAAA;AAMT;AAGO,eAAeL,oBAAoBY,MAAoC;QAYzDA;IAXnBX,MAAM,CAAC,mCAAmC,EAAEW,OAAOC,GAAG,CAAC,QAAQ,EAAED,OAAOE,IAAI,CAAC,CAAC,CAAC;IAC/E,IACE,iCAAiC;IACjCC,QAAQC,QAAQ,KAAK,YACrB,2BAA2B;IAC3BJ,OAAOE,IAAI,KAAK,YAChB;QACA,OAAO;IACT;IAEA,gDAAgD;IAChD,MAAMG,cAAaL,oBAAAA,OAAOC,GAAG,CAAEK,KAAK,CAAC,8BAAlBN,iBAA6B,CAAC,EAAE;IACnD,IAAI,CAACK,YAAY;QACf,OAAO;IACT;IACA,WAAW;IACX,MAAMJ,MAAMV,WAAWc;IAEvB,IAAI,CAACJ,KAAK;QACR,OAAO;IACT;IACAZ,MAAM,CAAC,wBAAwB,CAAC,EAAEY;IAClC,IAAI;QACF,MAAMM,aAAUC,SAAS,CAAC,CAAC;;0DAE2B,EAAEP,IAAI;YACpD,CAAC;QACT,OAAO;IACT,EAAE,OAAM;QACN,gEAAgE;QAChE,OAAO;IACT;AACF"}
node_modules/expo/node_modules/@expo/cli/build/src/start/doctor/apple/SimulatorAppPrerequisite.js:function _osascript() {
node_modules/expo/node_modules/@expo/cli/build/src/start/doctor/apple/SimulatorAppPrerequisite.js:    const data = require("@expo/osascript");
node_modules/expo/node_modules/@expo/cli/build/src/start/doctor/apple/SimulatorAppPrerequisite.js:    _osascript = function() {
node_modules/expo/node_modules/@expo/cli/build/src/start/doctor/apple/SimulatorAppPrerequisite.js:        return (await (0, _osascript().execAsync)('id of app "Simulator"')).trim();
node_modules/expo/node_modules/@expo/cli/build/src/start/doctor/apple/SimulatorAppPrerequisite.js.map:{"version":3,"sources":["../../../../../src/start/doctor/apple/SimulatorAppPrerequisite.ts"],"sourcesContent":["import { execAsync } from '@expo/osascript';\nimport spawnAsync from '@expo/spawn-async';\n\nimport * as Log from '../../../log';\nimport { Prerequisite, PrerequisiteCommandError } from '../Prerequisite';\n\nconst debug = require('debug')('expo:doctor:apple:simulatorApp') as typeof console.log;\n\nasync function getSimulatorAppIdAsync(): Promise<string | null> {\n  try {\n    return (await execAsync('id of app \"Simulator\"')).trim();\n  } catch {\n    // This error may occur in CI where the users intends to install just the simulators but no Xcode.\n  }\n  return null;\n}\n\nexport class SimulatorAppPrerequisite extends Prerequisite {\n  static instance = new SimulatorAppPrerequisite();\n\n  async assertImplementation(): Promise<void> {\n    const result = await getSimulatorAppIdAsync();\n    if (!result) {\n      // This error may occur in CI where the users intends to install just the simulators but no Xcode.\n      throw new PrerequisiteCommandError(\n        'SIMULATOR_APP',\n        \"Can't determine id of Simulator app; the Simulator is most likely not installed on this machine. Run `sudo xcode-select -s /Applications/Xcode.app`\"\n      );\n    }\n    if (\n      result !== 'com.apple.iphonesimulator' &&\n      result !== 'com.apple.CoreSimulator.SimulatorTrampoline'\n    ) {\n      throw new PrerequisiteCommandError(\n        'SIMULATOR_APP',\n        \"Simulator is installed but is identified as '\" + result + \"'; don't know what that is.\"\n      );\n    }\n    debug(`Simulator app id: ${result}`);\n\n    try {\n      // make sure we can run simctl\n      await spawnAsync('xcrun', ['simctl', 'help']);\n    } catch (error: any) {\n      Log.warn(`Unable to run simctl:\\n${error.toString()}`);\n      throw new PrerequisiteCommandError(\n        'SIMCTL',\n        'xcrun is not configured correctly. Ensure `sudo xcode-select --reset` works before running this command again.'\n      );\n    }\n  }\n}\n"],"names":["SimulatorAppPrerequisite","debug","require","getSimulatorAppIdAsync","execAsync","trim","Prerequisite","instance","assertImplementation","result","PrerequisiteCommandError","spawnAsync","error","Log","warn","toString"],"mappings":";;;;+BAiBaA;;;eAAAA;;;;yBAjBa;;;;;;;gEACH;;;;;;6DAEF;8BACkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEvD,MAAMC,QAAQC,QAAQ,SAAS;AAE/B,eAAeC;IACb,IAAI;QACF,OAAO,AAAC,CAAA,MAAMC,IAAAA,sBAAS,EAAC,wBAAuB,EAAGC,IAAI;IACxD,EAAE,OAAM;IACN,kGAAkG;IACpG;IACA,OAAO;AACT;AAEO,MAAML,iCAAiCM,0BAAY;qBACjDC,WAAW,IAAIP;IAEtB,MAAMQ,uBAAsC;QAC1C,MAAMC,SAAS,MAAMN;QACrB,IAAI,CAACM,QAAQ;YACX,kGAAkG;YAClG,MAAM,IAAIC,sCAAwB,CAChC,iBACA;QAEJ;QACA,IACED,WAAW,+BACXA,WAAW,+CACX;YACA,MAAM,IAAIC,sCAAwB,CAChC,iBACA,kDAAkDD,SAAS;QAE/D;QACAR,MAAM,CAAC,kBAAkB,EAAEQ,QAAQ;QAEnC,IAAI;YACF,8BAA8B;YAC9B,MAAME,IAAAA,qBAAU,EAAC,SAAS;gBAAC;gBAAU;aAAO;QAC9C,EAAE,OAAOC,OAAY;YACnBC,KAAIC,IAAI,CAAC,CAAC,uBAAuB,EAAEF,MAAMG,QAAQ,IAAI;YACrD,MAAM,IAAIL,sCAAwB,CAChC,UACA;QAEJ;IACF;AACF"}
node_modules/expo/node_modules/@expo/cli/build/src/start/server/middleware/inspector/createJsInspectorMiddleware.js.map:{"version":3,"sources":["../../../../../../src/start/server/middleware/inspector/createJsInspectorMiddleware.ts"],"sourcesContent":["import chalk from 'chalk';\nimport type { NextHandleFunction } from 'connect';\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport net from 'net';\nimport { TLSSocket } from 'tls';\nimport { URL } from 'url';\n\nimport { openJsInspector, queryInspectorAppAsync } from './JsInspector';\n\n/**\n * Create a middleware that handles new requests to open the debugger from the dev menu.\n * @todo(cedric): delete this middleware once we fully swap over to the new React Native JS Inspector.\n */\nexport function createJsInspectorMiddleware(): NextHandleFunction {\n  return async function (req: IncomingMessage, res: ServerResponse, next: (err?: Error) => void) {\n    const { origin, searchParams } = new URL(req.url ?? '/', getServerBase(req));\n    const appId = searchParams.get('appId') || searchParams.get('applicationId');\n    if (!appId) {\n      res.writeHead(400).end('Missing application identifier (\"?appId=...\")');\n      return;\n    }\n\n    const app = await queryInspectorAppAsync(origin, appId);\n    if (!app) {\n      res.writeHead(404).end('Unable to find inspector target from @react-native/dev-middleware');\n      console.warn(\n        chalk.yellow(\n          'No compatible apps connected. JavaScript Debugging can only be used with the Hermes engine.'\n        )\n      );\n      return;\n    }\n\n    if (req.method === 'GET') {\n      const data = JSON.stringify(app);\n      res.writeHead(200, {\n        'Content-Type': 'application/json; charset=UTF-8',\n        'Cache-Control': 'no-cache',\n        'Content-Length': data.length.toString(),\n      });\n      res.end(data);\n    } else if (req.method === 'POST' || req.method === 'PUT') {\n      try {\n        await openJsInspector(origin, app);\n      } catch (error: any) {\n        // abort(Error: Command failed: osascript -e POSIX path of (path to application \"google chrome\")\n        // 15:50: execution error: Google Chrome got an error: Application isn’t running. (-600)\n\n        console.error(\n          chalk.red('Error launching JS inspector: ' + (error?.message ?? 'Unknown error occurred'))\n        );\n        res.writeHead(500);\n        res.end();\n        return;\n      }\n      res.end();\n    } else {\n      res.writeHead(405);\n    }\n  };\n}\n\nfunction getServerBase(req: IncomingMessage): string {\n  const scheme =\n    req.socket instanceof TLSSocket && req.socket.encrypted === true ? 'https' : 'http';\n  const { localAddress, localPort } = req.socket;\n  const address = localAddress && net.isIPv6(localAddress) ? `[${localAddress}]` : localAddress;\n  return `${scheme}:${address}:${localPort}`;\n}\n"],"names":["createJsInspectorMiddleware","req","res","next","origin","searchParams","URL","url","getServerBase","appId","get","writeHead","end","app","queryInspectorAppAsync","console","warn","chalk","yellow","method","data","JSON","stringify","length","toString","openJsInspector","error","red","message","scheme","socket","TLSSocket","encrypted","localAddress","localPort","address","net","isIPv6"],"mappings":";;;;+BAagBA;;;eAAAA;;;;gEAbE;;;;;;;gEAGF;;;;;;;yBACU;;;;;;;yBACN;;;;;;6BAEoC;;;;;;AAMjD,SAASA;IACd,OAAO,eAAgBC,GAAoB,EAAEC,GAAmB,EAAEC,IAA2B;QAC3F,MAAM,EAAEC,MAAM,EAAEC,YAAY,EAAE,GAAG,IAAIC,CAAAA,MAAE,KAAC,CAACL,IAAIM,GAAG,IAAI,KAAKC,cAAcP;QACvE,MAAMQ,QAAQJ,aAAaK,GAAG,CAAC,YAAYL,aAAaK,GAAG,CAAC;QAC5D,IAAI,CAACD,OAAO;YACVP,IAAIS,SAAS,CAAC,KAAKC,GAAG,CAAC;YACvB;QACF;QAEA,MAAMC,MAAM,MAAMC,IAAAA,mCAAsB,EAACV,QAAQK;QACjD,IAAI,CAACI,KAAK;YACRX,IAAIS,SAAS,CAAC,KAAKC,GAAG,CAAC;YACvBG,QAAQC,IAAI,CACVC,gBAAK,CAACC,MAAM,CACV;YAGJ;QACF;QAEA,IAAIjB,IAAIkB,MAAM,KAAK,OAAO;YACxB,MAAMC,OAAOC,KAAKC,SAAS,CAACT;YAC5BX,IAAIS,SAAS,CAAC,KAAK;gBACjB,gBAAgB;gBAChB,iBAAiB;gBACjB,kBAAkBS,KAAKG,MAAM,CAACC,QAAQ;YACxC;YACAtB,IAAIU,GAAG,CAACQ;QACV,OAAO,IAAInB,IAAIkB,MAAM,KAAK,UAAUlB,IAAIkB,MAAM,KAAK,OAAO;YACxD,IAAI;gBACF,MAAMM,IAAAA,4BAAe,EAACrB,QAAQS;YAChC,EAAE,OAAOa,OAAY;gBACnB,gGAAgG;gBAChG,wFAAwF;gBAExFX,QAAQW,KAAK,CACXT,gBAAK,CAACU,GAAG,CAAC,mCAAoCD,CAAAA,CAAAA,yBAAAA,MAAOE,OAAO,KAAI,wBAAuB;gBAEzF1B,IAAIS,SAAS,CAAC;gBACdT,IAAIU,GAAG;gBACP;YACF;YACAV,IAAIU,GAAG;QACT,OAAO;YACLV,IAAIS,SAAS,CAAC;QAChB;IACF;AACF;AAEA,SAASH,cAAcP,GAAoB;IACzC,MAAM4B,SACJ5B,IAAI6B,MAAM,YAAYC,gBAAS,IAAI9B,IAAI6B,MAAM,CAACE,SAAS,KAAK,OAAO,UAAU;IAC/E,MAAM,EAAEC,YAAY,EAAEC,SAAS,EAAE,GAAGjC,IAAI6B,MAAM;IAC9C,MAAMK,UAAUF,gBAAgBG,cAAG,CAACC,MAAM,CAACJ,gBAAgB,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,GAAGA;IACjF,OAAO,GAAGJ,OAAO,CAAC,EAAEM,QAAQ,CAAC,EAAED,WAAW;AAC5C"}
node_modules/expo/node_modules/@expo/cli/build/src/start/server/middleware/inspector/createJsInspectorMiddleware.js:                // abort(Error: Command failed: osascript -e POSIX path of (path to application "google chrome")
